!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
AS	makefile	/^AS = nasm$/;"	m
ASFLAGS	makefile	/^ASFLAGS = -f elf$/;"	m
ASSERT	kernel/debug.h	/^    #define ASSERT(/;"	d
ASSERT	kernel/debug.h	/^#define ASSERT(/;"	d
BITMAP_MASK	lib/kernel/bitmap.h	/^#define BITMAP_MASK /;"	d
BITS_PER_SECTOR	fs/fs.h	/^#define BITS_PER_SECTOR /;"	d
BIT_DEV_DEV	device/ide.c	/^#define BIT_DEV_DEV	/;"	d	file:
BIT_DEV_LBA	device/ide.c	/^#define BIT_DEV_LBA	/;"	d	file:
BIT_DEV_MBS	device/ide.c	/^#define BIT_DEV_MBS	/;"	d	file:
BIT_STAT_BSY	device/ide.c	/^#define BIT_STAT_BSY	/;"	d	file:
BIT_STAT_DRDY	device/ide.c	/^#define BIT_STAT_DRDY	/;"	d	file:
BIT_STAT_DRQ	device/ide.c	/^#define BIT_STAT_DRQ	/;"	d	file:
BLOCK_BITMAP	fs/file.h	/^    BLOCK_BITMAP  \/\/ 块位图$/;"	e	enum:bitmap_type
BLOCK_SIZE	fs/fs.h	/^#define BLOCK_SIZE /;"	d
BUILD_DIR	makefile	/^BUILD_DIR = .\/build$/;"	m
CC	makefile	/^CC = x86_64-elf-gcc$/;"	m
CFLAGS	makefile	/^CFLAGS = -Wall $(LIB) -m32 -c -fno-builtin -W -Wstrict-prototypes \\$/;"	m
CMD_IDENTIFY	device/ide.c	/^#define CMD_IDENTIFY	/;"	d	file:
CMD_READ_SECTOR	device/ide.c	/^#define CMD_READ_SECTOR	/;"	d	file:
CMD_WRITE_SECTOR	device/ide.c	/^#define CMD_WRITE_SECTOR /;"	d	file:
CODE_DESC	boot/loader.S	/^CODE_DESC: dd 0x0000FFFF$/;"	d
CONTRER0_PORT	device/timer.c	/^#define CONTRER0_PORT	/;"	d	file:
COUNTER0_NO	device/timer.c	/^#define COUNTER0_NO	/;"	d	file:
COUNTER0_VALUE	device/timer.c	/^#define COUNTER0_VALUE	/;"	d	file:
COUNTER_MODE	device/timer.c	/^#define COUNTER_MODE	/;"	d	file:
DATA_STACK_DESC	boot/loader.S	/^DATA_STACK_DESC: dd 0x0000FFFF$/;"	d
DESC_AVL	kernel/global.h	/^#define DESC_AVL /;"	d
DESC_CNT	kernel/memory.h	/^#define DESC_CNT /;"	d
DESC_DPL_0	kernel/global.h	/^#define DESC_DPL_0 /;"	d
DESC_DPL_1	kernel/global.h	/^#define DESC_DPL_1 /;"	d
DESC_DPL_2	kernel/global.h	/^#define DESC_DPL_2 /;"	d
DESC_DPL_3	kernel/global.h	/^#define DESC_DPL_3 /;"	d
DESC_D_32	kernel/global.h	/^#define	DESC_D_32 /;"	d
DESC_G_4K	kernel/global.h	/^#define	DESC_G_4K /;"	d
DESC_L	kernel/global.h	/^#define DESC_L	/;"	d
DESC_P	kernel/global.h	/^#define DESC_P	/;"	d
DESC_S_CODE	kernel/global.h	/^#define DESC_S_CODE	/;"	d
DESC_S_DATA	kernel/global.h	/^#define DESC_S_DATA	/;"	d
DESC_S_SYS	kernel/global.h	/^#define DESC_S_SYS	/;"	d
DESC_TYPE_CODE	kernel/global.h	/^#define DESC_TYPE_CODE	/;"	d
DESC_TYPE_DATA	kernel/global.h	/^#define DESC_TYPE_DATA /;"	d
DESC_TYPE_TSS	kernel/global.h	/^#define DESC_TYPE_TSS /;"	d
DIV_ROUND_UP	kernel/global.h	/^#define DIV_ROUND_UP(/;"	d
EFLAGS_IF	kernel/interrupt.c	/^#define EFLAGS_IF /;"	d	file:
EFLAGS_IF_0	kernel/global.h	/^#define EFLAGS_IF_0 /;"	d
EFLAGS_IF_1	kernel/global.h	/^#define EFLAGS_IF_1 /;"	d
EFLAGS_IOPL_0	kernel/global.h	/^#define EFLAGS_IOPL_0 /;"	d
EFLAGS_IOPL_3	kernel/global.h	/^#define EFLAGS_IOPL_3 /;"	d
EFLAGS_MBS	kernel/global.h	/^#define EFLAGS_MBS /;"	d
ENTRY_POINT	makefile	/^ENTRY_POINT = 0xc0001500$/;"	m
FT_DIRECTORY	fs/fs.h	/^    FT_DIRECTORY \/\/ 目录$/;"	e	enum:file_types
FT_REGULAR	fs/fs.h	/^    FT_REGULAR,  \/\/ 普通文件$/;"	e	enum:file_types
FT_UNKNOWN	fs/fs.h	/^    FT_UNKNOWN,  \/\/ 不支持的文件类型$/;"	e	enum:file_types
GDT_ATTR_HIGH	kernel/global.h	/^#define GDT_ATTR_HIGH	/;"	d
GDT_BASE	boot/loader.S	/^GDT_BASE: dd 0x00000000$/;"	d
GDT_CODE_ATTR_LOW_DPL3	kernel/global.h	/^#define GDT_CODE_ATTR_LOW_DPL3	/;"	d
GDT_DATA_ATTR_LOW_DPL3	kernel/global.h	/^#define GDT_DATA_ATTR_LOW_DPL3	/;"	d
GDT_LIMIT	boot/loader.S	/^GDT_LIMIT equ GDT_SIZE - 1$/;"	d
GDT_SIZE	boot/loader.S	/^GDT_SIZE equ $ - GDT_BASE$/;"	d
GET_EFLAGS	kernel/interrupt.c	/^#define GET_EFLAGS(/;"	d	file:
IDT_DESC_16_TYPE	kernel/global.h	/^#define IDT_DESC_16_TYPE /;"	d
IDT_DESC_32_TYPE	kernel/global.h	/^#define IDT_DESC_32_TYPE /;"	d
IDT_DESC_ATTR_DPL0	kernel/global.h	/^#define IDT_DESC_ATTR_DPL0 /;"	d
IDT_DESC_ATTR_DPL3	kernel/global.h	/^#define IDT_DESC_ATTR_DPL3 /;"	d
IDT_DESC_CNT	kernel/interrupt.c	/^#define IDT_DESC_CNT /;"	d	file:
IDT_DESC_DPL0	kernel/global.h	/^#define IDT_DESC_DPL0 /;"	d
IDT_DESC_DPL3	kernel/global.h	/^#define IDT_DESC_DPL3 /;"	d
IDT_DESC_P	kernel/global.h	/^#define IDT_DESC_P /;"	d
INODE_BITMAP	fs/file.h	/^    INODE_BITMAP, \/\/ inode 位图$/;"	e	enum:bitmap_type
INPUT_FREQUENCY	device/timer.c	/^#define INPUT_FREQUENCY	/;"	d	file:
INTR_OFF	kernel/interrupt.h	/^    INTR_OFF,$/;"	e	enum:intr_status
INTR_ON	kernel/interrupt.h	/^    INTR_ON$/;"	e	enum:intr_status
IRQ0_FREQUENCY	device/timer.c	/^#define IRQ0_FREQUENCY	/;"	d	file:
KBD_BUF_PORT	device/keyboard.c	/^#define KBD_BUF_PORT /;"	d	file:
K_HEAP_START	kernel/memory.c	/^#define K_HEAP_START /;"	d	file:
LD	makefile	/^LD = x86_64-elf-ld$/;"	m
LDFLAGS	makefile	/^LDFLAGS = -Ttext $(ENTRY_POINT) -melf_i386 -e main -Map $(BUILD_DIR)\/kernel.map$/;"	m
LIB	makefile	/^LIB = -I lib\/ -I lib\/kernel\/ -I lib\/user\/ -I kernel\/ -I device\/ -I thread\/ -I userprog\/ -I fs\/$/;"	m
LOADER_STACK_TOP	boot/loader.S	/^LOADER_STACK_TOP equ LOADER_BASE_ADDR$/;"	d
MAX_FILES_OPEN_PER_PROC	thread/thread.h	/^#define MAX_FILES_OPEN_PER_PROC /;"	d
MAX_FILES_PER_PART	fs/fs.h	/^#define MAX_FILES_PER_PART /;"	d
MAX_FILE_NAME_LEN	fs/dir.h	/^#define MAX_FILE_NAME_LEN /;"	d
MAX_FILE_OPEN	fs/file.h	/^#define MAX_FILE_OPEN /;"	d
MAX_PATH_LEN	fs/fs.h	/^#define MAX_PATH_LEN /;"	d
MEM_BITMAP_BASE	kernel/memory.c	/^#define MEM_BITMAP_BASE /;"	d	file:
NULL	kernel/global.h	/^#define NULL /;"	d
OBJS	makefile	/^OBJS = $(BUILD_DIR)\/main.o $(BUILD_DIR)\/init.o $(BUILD_DIR)\/interrupt.o \\$/;"	m
O_CREAT	fs/fs.h	/^    O_CREAT = 4 \/\/ 创建$/;"	e	enum:oflags
O_RDONLY	fs/fs.h	/^    O_RDONLY,   \/\/ 只读$/;"	e	enum:oflags
O_RDWR	fs/fs.h	/^    O_RDWR,     \/\/ 读写$/;"	e	enum:oflags
O_WRONLY	fs/fs.h	/^    O_WRONLY,   \/\/ 只写$/;"	e	enum:oflags
PANIC	kernel/debug.h	/^#define PANIC(/;"	d
PDE_IDX	kernel/memory.c	/^#define PDE_IDX(/;"	d	file:
PF_KERNEL	kernel/memory.h	/^    PF_KERNEL = 1, \/\/ 内核内存池$/;"	e	enum:pool_flags
PF_USER	kernel/memory.h	/^    PF_USER = 2    \/\/ 用户内存池$/;"	e	enum:pool_flags
PG_P_0	kernel/memory.h	/^#define PG_P_0 /;"	d
PG_P_1	kernel/memory.h	/^#define PG_P_1 /;"	d
PG_RW_R	kernel/memory.h	/^#define PG_RW_R /;"	d
PG_RW_W	kernel/memory.h	/^#define PG_RW_W /;"	d
PG_SIZE	kernel/global.h	/^#define PG_SIZE /;"	d
PG_US_S	kernel/memory.h	/^#define PG_US_S /;"	d
PG_US_U	kernel/memory.h	/^#define PG_US_U /;"	d
PIC_M_CTRL	kernel/interrupt.c	/^#define PIC_M_CTRL /;"	d	file:
PIC_M_DATA	kernel/interrupt.c	/^#define PIC_M_DATA /;"	d	file:
PIC_S_CTRL	kernel/interrupt.c	/^#define PIC_S_CTRL /;"	d	file:
PIC_S_DATA	kernel/interrupt.c	/^#define PIC_S_DATA /;"	d	file:
PIT_CONTROL_PORT	device/timer.c	/^#define PIT_CONTROL_PORT /;"	d	file:
PTE_IDX	kernel/memory.c	/^#define PTE_IDX(/;"	d	file:
READ_WRITE_LATCH	device/timer.c	/^#define READ_WRITE_LATCH /;"	d	file:
RPL0	kernel/global.h	/^#define RPL0 /;"	d
RPL0	lib/kernel/print.S	/^RPL0  equ   0$/;"	d
RPL1	kernel/global.h	/^#define RPL1 /;"	d
RPL2	kernel/global.h	/^#define RPL2 /;"	d
RPL3	kernel/global.h	/^#define RPL3 /;"	d
SECTION	boot/loader.S	/^SECTION LOADER vstart=LOADER_BASE_ADDR$/;"	l
SECTION	boot/mbr.S	/^SECTION MBR vstart=0x7c00 ; 把起始地址编译为 0x7c00$/;"	l
SECTOR_SIZE	fs/fs.h	/^#define SECTOR_SIZE /;"	d
SELECTOR_CODE	boot/loader.S	/^SELECTOR_CODE  equ (0x0001<<3) + TI_GDT + RPL0$/;"	d
SELECTOR_DATA	boot/loader.S	/^SELECTOR_DATA  equ (0x0002<<3) + TI_GDT + RPL0$/;"	d
SELECTOR_K_CODE	kernel/global.h	/^#define SELECTOR_K_CODE /;"	d
SELECTOR_K_DATA	kernel/global.h	/^#define SELECTOR_K_DATA /;"	d
SELECTOR_K_GS	kernel/global.h	/^#define SELECTOR_K_GS /;"	d
SELECTOR_K_STACK	kernel/global.h	/^#define SELECTOR_K_STACK /;"	d
SELECTOR_TSS	kernel/global.h	/^#define SELECTOR_TSS /;"	d
SELECTOR_U_CODE	kernel/global.h	/^#define SELECTOR_U_CODE	/;"	d
SELECTOR_U_DATA	kernel/global.h	/^#define SELECTOR_U_DATA	/;"	d
SELECTOR_U_STACK	kernel/global.h	/^#define SELECTOR_U_STACK /;"	d
SELECTOR_VIDEO	boot/loader.S	/^SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0$/;"	d
SELECTOR_VIDEO	lib/kernel/print.S	/^SELECTOR_VIDEO equ (0x0003<<3) + TI_GDT + RPL0$/;"	d
SYSCALL_NR	lib/user/syscall.h	/^enum SYSCALL_NR {$/;"	g
SYS_FREE	lib/user/syscall.h	/^   SYS_FREE$/;"	e	enum:SYSCALL_NR
SYS_GETPID	lib/user/syscall.h	/^   SYS_GETPID,$/;"	e	enum:SYSCALL_NR
SYS_MALLOC	lib/user/syscall.h	/^   SYS_MALLOC,$/;"	e	enum:SYSCALL_NR
SYS_WRITE	lib/user/syscall.h	/^   SYS_WRITE,$/;"	e	enum:SYSCALL_NR
TASK_BLOCKED	thread/thread.h	/^    TASK_BLOCKED,$/;"	e	enum:task_status
TASK_DIED	thread/thread.h	/^    TASK_DIED$/;"	e	enum:task_status
TASK_HANGING	thread/thread.h	/^    TASK_HANGING,$/;"	e	enum:task_status
TASK_READY	thread/thread.h	/^    TASK_READY,$/;"	e	enum:task_status
TASK_RUNNING	thread/thread.h	/^    TASK_RUNNING,$/;"	e	enum:task_status
TASK_WAITING	thread/thread.h	/^    TASK_WAITING,$/;"	e	enum:task_status
TI_GDT	kernel/global.h	/^#define TI_GDT /;"	d
TI_GDT	lib/kernel/print.S	/^TI_GDT equ  0$/;"	d
TI_LDT	kernel/global.h	/^#define TI_LDT /;"	d
TSS_ATTR_HIGH	kernel/global.h	/^#define TSS_ATTR_HIGH /;"	d
TSS_ATTR_LOW	kernel/global.h	/^#define TSS_ATTR_LOW /;"	d
TSS_DESC_D	kernel/global.h	/^#define TSS_DESC_D /;"	d
UNUSED	kernel/global.h	/^#define UNUSED /;"	d
USER_STACK3_VADDR	userprog/process.h	/^#define USER_STACK3_VADDR /;"	d
USER_VADDR_START	userprog/process.h	/^#define USER_VADDR_START /;"	d
VECTOR	kernel/kernel.S	/^VECTOR 0x00, ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x01, ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x02, ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x03, ZERO $/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x04, ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x05, ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x06, ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x07, ZERO $/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x08, ERROR_CODE$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x09, ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x0a, ERROR_CODE$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x0b, ERROR_CODE $/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x0c, ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x0d, ERROR_CODE$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x0e, ERROR_CODE$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x0f, ZERO $/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x10, ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x11, ERROR_CODE$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x12, ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x13, ZERO $/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x14, ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x15, ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x16, ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x17, ZERO $/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x18, ERROR_CODE$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x19, ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x1a, ERROR_CODE$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x1b, ERROR_CODE $/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x1c, ZERO$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x1d, ERROR_CODE$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x1e, ERROR_CODE$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x1f, ZERO $/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x20,ZERO	;时钟中断对应的入口$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x21,ZERO	;键盘中断对应的入口$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x22,ZERO	;级联用的$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x23,ZERO	;串口2对应的入口$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x24,ZERO	;串口1对应的入口$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x25,ZERO	;并口2对应的入口$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x26,ZERO	;软盘对应的入口$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x27,ZERO	;并口1对应的入口$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x28,ZERO	;实时时钟对应的入口$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x29,ZERO	;重定向$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x2a,ZERO	;保留$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x2b,ZERO	;保留$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x2c,ZERO	;ps\/2鼠标$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x2d,ZERO	;fpu浮点单元异常$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x2e,ZERO	;硬盘$/;"	l
VECTOR	kernel/kernel.S	/^VECTOR 0x2f,ZERO	;保留$/;"	l
VIDEO_DESC	boot/loader.S	/^VIDEO_DESC: dd 0x80000007 ; limit = (0xbffff - 0xb8000) \/ 4k = 0x7$/;"	d
__DEVICE_CONSOLE_H	device/console.h	/^#define __DEVICE_CONSOLE_H$/;"	d
__DEVICE_IDE_H	device/ide.h	/^#define __DEVICE_IDE_H$/;"	d
__DEVICE_IOQUEUE_H	device/ioqueue.h	/^#define __DEVICE_IOQUEUE_H$/;"	d
__DEVICE_KEYBOARD_H	device/keyboard.h	/^#define __DEVICE_KEYBOARD_H$/;"	d
__DEVICE_TIME_H	device/timer.h	/^#define __DEVICE_TIME_H$/;"	d
__FS_DIR_H	fs/dir.h	/^#define __FS_DIR_H$/;"	d
__FS_FILE_H	fs/file.h	/^#define __FS_FILE_H$/;"	d
__FS_FS_H	fs/fs.h	/^#define __FS_FS_H$/;"	d
__FS_INODE_H	fs/inode.h	/^#define __FS_INODE_H$/;"	d
__FS_SUPER_BLOCK_H	fs/super_block.h	/^#define __FS_SUPER_BLOCK_H$/;"	d
__KERNEL_DEBUG_H	kernel/debug.h	/^#define __KERNEL_DEBUG_H$/;"	d
__KERNEL_GLOBAL_H	kernel/global.h	/^#define __KERNEL_GLOBAL_H$/;"	d
__KERNEL_INIT_H	kernel/init.h	/^#define __KERNEL_INIT_H$/;"	d
__KERNEL_INTERRUPT_H	kernel/interrupt.h	/^#define __KERNEL_INTERRUPT_H$/;"	d
__KERNEL_MEMORY_H	kernel/memory.h	/^#define __KERNEL_MEMORY_H$/;"	d
__LIB_IO_H	lib/kernel/io.h	/^#define __LIB_IO_H$/;"	d
__LIB_KERNEL_BITMAP_H	lib/kernel/bitmap.h	/^#define __LIB_KERNEL_BITMAP_H$/;"	d
__LIB_KERNEL_LIST_H	lib/kernel/list.h	/^#define __LIB_KERNEL_LIST_H$/;"	d
__LIB_KERNEL_PRINT_H	lib/kernel/print.h	/^#define __LIB_KERNEL_PRINT_H$/;"	d
__LIB_KERNEL_STDIOSYS_H	lib/kernel/stdio-kernel.h	/^#define __LIB_KERNEL_STDIOSYS_H$/;"	d
__LIB_STDINT_H	lib/stdint.h	/^#define __LIB_STDINT_H$/;"	d
__LIB_STDIO_H	lib/stdio.h	/^#define __LIB_STDIO_H$/;"	d
__LIB_STRING_H	lib/string.h	/^#define __LIB_STRING_H$/;"	d
__LIB_USER_SYSCALL_H	lib/user/syscall.h	/^#define __LIB_USER_SYSCALL_H$/;"	d
__THREAD_SYNC_H	thread/sync.h	/^#define __THREAD_SYNC_H$/;"	d
__THREAD_THREAD_H	thread/thread.h	/^#define __THREAD_THREAD_H$/;"	d
__USERPROG_PROCESS_H	userprog/process.h	/^#define __USERPROG_PROCESS_H$/;"	d
__USERPROG_SYSCALLINIT_H	userprog/syscall-init.h	/^#define __USERPROG_SYSCALLINIT_H$/;"	d
__USERPROG_TSS_H	userprog/tss.h	/^#define __USERPROG_TSS_H$/;"	d
_syscall0	lib/user/syscall.c	/^#define _syscall0(/;"	d	file:
_syscall1	lib/user/syscall.c	/^#define _syscall1(/;"	d	file:
_syscall2	lib/user/syscall.c	/^#define _syscall2(/;"	d	file:
_syscall3	lib/user/syscall.c	/^#define _syscall3(/;"	d	file:
addr_v2p	kernel/memory.c	/^uint32_t addr_v2p(uint32_t vaddr) {$/;"	f
all_list_tag	thread/thread.h	/^    struct list_elem all_list_tag; \/\/ 用于线程在 thread_all_list 中的结点$/;"	m	struct:task_struct	typeref:struct:task_struct::list_elem
allocate_pid	thread/thread.c	/^static pid_t allocate_pid(void) {$/;"	f	file:
alt_l_char	device/keyboard.c	/^#define alt_l_char	/;"	d	file:
alt_l_make	device/keyboard.c	/^#define alt_l_make /;"	d	file:
alt_r_break	device/keyboard.c	/^#define alt_r_break /;"	d	file:
alt_r_char	device/keyboard.c	/^#define alt_r_char	/;"	d	file:
alt_r_make	device/keyboard.c	/^#define alt_r_make /;"	d	file:
alt_status	device/keyboard.c	/^static bool ctrl_status, shift_status, alt_status, caps_lock_status, ext_scancode;$/;"	v	file:
ards_buf	boot/loader.S	/^ards_buf times 244 db 0$/;"	l
ards_nr	boot/loader.S	/^ards_nr dw 0 ; ards_nr 用于记录 ARDS 结构体数量$/;"	d
arena	kernel/memory.c	/^struct arena {$/;"	s	file:
arena2block	kernel/memory.c	/^static struct mem_block* arena2block(struct arena* a, uint32_t idx) {$/;"	f	file:
attr_low_byte	kernel/global.h	/^   uint8_t  attr_low_byte;$/;"	m	struct:gdt_desc
attribute	kernel/interrupt.c	/^    uint8_t  attribute;$/;"	m	struct:gate_desc	file:
backlink	userprog/tss.c	/^    uint32_t backlink;$/;"	m	struct:tss	file:
backspace	device/keyboard.c	/^#define backspace	/;"	d	file:
base_high_byte	kernel/global.h	/^   uint8_t  base_high_byte;$/;"	m	struct:gdt_desc
base_low_word	kernel/global.h	/^   uint16_t base_low_word;$/;"	m	struct:gdt_desc
base_mid_byte	kernel/global.h	/^   uint8_t  base_mid_byte;$/;"	m	struct:gdt_desc
bitmap	lib/kernel/bitmap.h	/^struct bitmap {$/;"	s
bitmap_init	lib/kernel/bitmap.c	/^void bitmap_init(struct bitmap* btmp) {$/;"	f
bitmap_scan	lib/kernel/bitmap.c	/^int bitmap_scan(struct bitmap* btmp, uint32_t cnt) {$/;"	f
bitmap_scan_test	lib/kernel/bitmap.c	/^bool bitmap_scan_test(struct bitmap* btmp, uint32_t bit_idx) {$/;"	f
bitmap_set	lib/kernel/bitmap.c	/^void bitmap_set(struct bitmap* btmp, uint32_t bit_idx, int8_t value) {$/;"	f
bitmap_sync	fs/file.c	/^void bitmap_sync(struct partition* part, uint32_t bit_idx, uint8_t btmp) {$/;"	f
bitmap_type	fs/file.h	/^enum bitmap_type {$/;"	g
bits	lib/kernel/bitmap.h	/^   uint8_t* bits;$/;"	m	struct:bitmap
block2arena	kernel/memory.c	/^static struct arena* block2arena(struct mem_block* b) {$/;"	f	file:
block_bitmap	device/ide.h	/^    struct bitmap block_bitmap; \/\/ 块位图$/;"	m	struct:partition	typeref:struct:partition::bitmap
block_bitmap_alloc	fs/file.c	/^int32_t block_bitmap_alloc(struct partition* part) {$/;"	f
block_bitmap_lba	fs/super_block.h	/^    uint32_t block_bitmap_lba;   \/\/ 块位图本身起始扇区地址$/;"	m	struct:super_block
block_bitmap_sects	fs/super_block.h	/^    uint32_t block_bitmap_sects; \/\/ 扇区位图本身占用的扇区数量$/;"	m	struct:super_block
block_desc_init	kernel/memory.c	/^void block_desc_init(struct mem_block_desc* desc_array) {$/;"	f
block_size	kernel/memory.h	/^    uint32_t block_size; \/\/ 内存块大小$/;"	m	struct:mem_block_desc
blocks_per_arena	kernel/memory.h	/^    uint32_t blocks_per_arena; \/\/ 本 arena 中可容纳此 mem_block 的数量$/;"	m	struct:mem_block_desc
bool	kernel/global.h	/^#define bool /;"	d
boot_sector	device/ide.c	/^struct boot_sector {$/;"	s	file:
bootable	device/ide.c	/^    uint8_t  bootable;		 \/\/ 是否可引导	$/;"	m	struct:partition_table_entry	file:
btmp_bytes_len	lib/kernel/bitmap.h	/^   uint32_t btmp_bytes_len;$/;"	m	struct:bitmap
buf	device/ioqueue.h	/^    char buf[bufsize];			    \/\/ 缓冲区大小$/;"	m	struct:ioqueue
bufsize	device/ioqueue.h	/^#define bufsize /;"	d
busy_wait	device/ide.c	/^static bool busy_wait(struct disk* hd) {$/;"	f	file:
caps_lock_char	device/keyboard.c	/^#define caps_lock_char	/;"	d	file:
caps_lock_make	device/keyboard.c	/^#define caps_lock_make /;"	d	file:
caps_lock_status	device/keyboard.c	/^static bool ctrl_status, shift_status, alt_status, caps_lock_status, ext_scancode;$/;"	v	file:
channel_cnt	device/ide.c	/^uint8_t channel_cnt;	   \/\/ 按硬盘数计算的通道数$/;"	v
channels	device/ide.c	/^struct ide_channel channels[2];	 \/\/ 有两个ide通道$/;"	v	typeref:struct:ide_channel
char_invisible	device/keyboard.c	/^#define char_invisible	/;"	d	file:
cmd_out	device/ide.c	/^static void cmd_out(struct ide_channel* channel, uint8_t cmd) {$/;"	f	file:
cnt	kernel/memory.c	/^    uint32_t cnt;$/;"	m	struct:arena	file:
console_acquire	device/console.c	/^void console_acquire() {$/;"	f
console_init	device/console.c	/^void console_init() {$/;"	f
console_lock	device/console.c	/^static struct lock console_lock;    \/\/ 控制台锁$/;"	v	typeref:struct:lock	file:
console_put_char	device/console.c	/^void console_put_char(uint8_t char_asci) {$/;"	f
console_put_int	device/console.c	/^void console_put_int(uint32_t num) {$/;"	f
console_put_str	device/console.c	/^void console_put_str(char* str) {$/;"	f
console_release	device/console.c	/^void console_release() {$/;"	f
consumer	device/ioqueue.h	/^    struct task_struct* consumer;$/;"	m	struct:ioqueue	typeref:struct:ioqueue::task_struct
cr3	userprog/tss.c	/^    uint32_t cr3;$/;"	m	struct:tss	file:
create_dir_entry	fs/dir.c	/^void create_dir_entry(char* filename, $/;"	f
create_page_dir	userprog/process.c	/^uint32_t* create_page_dir(void) {$/;"	f
create_user_vaddr_bitmap	userprog/process.c	/^void create_user_vaddr_bitmap(struct task_struct* user_prog) {$/;"	f
cs	thread/thread.h	/^    uint32_t cs;$/;"	m	struct:intr_stack
cs	userprog/tss.c	/^    uint32_t cs;$/;"	m	struct:tss	file:
ctrl_l_char	device/keyboard.c	/^#define ctrl_l_char	/;"	d	file:
ctrl_l_make	device/keyboard.c	/^#define ctrl_l_make /;"	d	file:
ctrl_r_break	device/keyboard.c	/^#define ctrl_r_break /;"	d	file:
ctrl_r_char	device/keyboard.c	/^#define ctrl_r_char	/;"	d	file:
ctrl_r_make	device/keyboard.c	/^#define ctrl_r_make /;"	d	file:
ctrl_status	device/keyboard.c	/^static bool ctrl_status, shift_status, alt_status, caps_lock_status, ext_scancode;$/;"	v	file:
cur_part	fs/fs.c	/^struct partition* cur_part; \/\/ 默认情况下操作的是哪个分区$/;"	v	typeref:struct:partition
data_start_lba	fs/super_block.h	/^    uint32_t data_start_lba; \/\/ 数据区开始的第一个扇区号$/;"	m	struct:super_block
db	boot/mbr.S	/^db 0x55, 0xaa/;"	l
dcount	kernel/interrupt.c	/^    uint8_t  dcount;$/;"	m	struct:gate_desc	file:
default_prio	userprog/process.h	/^#define default_prio /;"	d
delete	device/keyboard.c	/^#define delete	/;"	d	file:
desc	kernel/memory.c	/^    struct mem_block_desc* desc;$/;"	m	struct:arena	typeref:struct:arena::mem_block_desc	file:
dev_no	device/ide.h	/^    uint8_t dev_no;                 \/\/ 本硬盘是主 0, 还是从 1$/;"	m	struct:disk
devices	device/ide.h	/^    struct disk devices[2];     \/\/ 一个通道上连接两个硬盘, 一主一从$/;"	m	struct:ide_channel	typeref:struct:ide_channel::disk
dir	fs/dir.h	/^struct dir {$/;"	s
dir_buf	fs/dir.h	/^    uint8_t dir_buf[512]; \/\/ 目录的数据缓冲$/;"	m	struct:dir
dir_close	fs/dir.c	/^void dir_close(struct dir* dir) {$/;"	f
dir_entry	fs/dir.h	/^struct dir_entry {$/;"	s
dir_entry_size	fs/super_block.h	/^    uint32_t dir_entry_size; \/\/ 目录项大小$/;"	m	struct:super_block
dir_open	fs/dir.c	/^struct dir* dir_open(struct partition* part, uint32_t inode_no) {$/;"	f
dir_pos	fs/dir.h	/^    uint32_t dir_pos; \/\/ 记录在目录内的偏移$/;"	m	struct:dir
disk	device/ide.h	/^struct disk {$/;"	s
disk_done	device/ide.h	/^    struct semaphore disk_done; \/\/ 用于阻塞、唤醒驱动程序$/;"	m	struct:ide_channel	typeref:struct:ide_channel::semaphore
ds	thread/thread.h	/^    uint32_t ds;$/;"	m	struct:intr_stack
ds	userprog/tss.c	/^    uint32_t ds;$/;"	m	struct:tss	file:
eax	thread/thread.h	/^    uint32_t eax;$/;"	m	struct:intr_stack
eax	userprog/tss.c	/^    uint32_t eax;$/;"	m	struct:tss	file:
ebp	thread/thread.h	/^    uint32_t ebp;$/;"	m	struct:intr_stack
ebp	thread/thread.h	/^    uint32_t ebp;$/;"	m	struct:thread_stack
ebp	userprog/tss.c	/^    uint32_t ebp;$/;"	m	struct:tss	file:
ebx	thread/thread.h	/^    uint32_t ebx;$/;"	m	struct:intr_stack
ebx	thread/thread.h	/^    uint32_t ebx;$/;"	m	struct:thread_stack
ebx	userprog/tss.c	/^    uint32_t ebx;$/;"	m	struct:tss	file:
ecx	thread/thread.h	/^    uint32_t ecx;$/;"	m	struct:intr_stack
ecx	userprog/tss.c	/^    uint32_t ecx;$/;"	m	struct:tss	file:
edi	thread/thread.h	/^    uint32_t edi;$/;"	m	struct:intr_stack
edi	thread/thread.h	/^    uint32_t edi;$/;"	m	struct:thread_stack
edi	userprog/tss.c	/^    uint32_t edi;$/;"	m	struct:tss	file:
edx	thread/thread.h	/^    uint32_t edx;$/;"	m	struct:intr_stack
edx	userprog/tss.c	/^    uint32_t edx;$/;"	m	struct:tss	file:
eflags	thread/thread.h	/^    uint32_t eflags;$/;"	m	struct:intr_stack
eflags	userprog/tss.c	/^    uint32_t eflags;$/;"	m	struct:tss	file:
eip	thread/thread.h	/^    void (*eip) (thread_func* func, void* func_arg);$/;"	m	struct:thread_stack
eip	thread/thread.h	/^    void (*eip) (void);$/;"	m	struct:intr_stack
eip	userprog/tss.c	/^    uint32_t (*eip) (void);$/;"	m	struct:tss	file:
elapsed_ticks	thread/thread.h	/^    uint32_t elapsed_ticks; \/\/ 此任务上 cpu 运行后至今占用了多少嘀嗒数$/;"	m	struct:task_struct
elem2entry	lib/kernel/list.h	/^#define elem2entry(/;"	d
elem_find	lib/kernel/list.c	/^bool elem_find(struct list* plist, struct list_elem* obj_elem) {$/;"	f
end_chs	device/ide.c	/^    uint8_t  end_chs;		 \/\/ 结束柱面号$/;"	m	struct:partition_table_entry	file:
end_head	device/ide.c	/^    uint8_t  end_head;		 \/\/ 结束磁头号$/;"	m	struct:partition_table_entry	file:
end_sec	device/ide.c	/^    uint8_t  end_sec;		 \/\/ 结束扇区号$/;"	m	struct:partition_table_entry	file:
enter	device/keyboard.c	/^#define enter	/;"	d	file:
enter_kernel	boot/loader.S	/^enter_kernel:$/;"	l
err_code	thread/thread.h	/^    uint32_t err_code;		 \/\/ err_code会被压入在eip之后$/;"	m	struct:intr_stack
es	thread/thread.h	/^    uint32_t es;$/;"	m	struct:intr_stack
es	userprog/tss.c	/^    uint32_t es;$/;"	m	struct:tss	file:
esc	device/keyboard.c	/^#define esc	/;"	d	file:
esi	thread/thread.h	/^    uint32_t esi;$/;"	m	struct:intr_stack
esi	thread/thread.h	/^    uint32_t esi;$/;"	m	struct:thread_stack
esi	userprog/tss.c	/^    uint32_t esi;$/;"	m	struct:tss	file:
esp	thread/thread.h	/^    void* esp;$/;"	m	struct:intr_stack
esp	userprog/tss.c	/^    uint32_t esp;$/;"	m	struct:tss	file:
esp0	userprog/tss.c	/^    uint32_t* esp0;$/;"	m	struct:tss	file:
esp1	userprog/tss.c	/^    uint32_t* esp1;$/;"	m	struct:tss	file:
esp2	userprog/tss.c	/^    uint32_t* esp2;$/;"	m	struct:tss	file:
esp_dummy	thread/thread.h	/^    uint32_t esp_dummy;	 \/\/ 虽然pushad把esp也压入,但esp是不断变化的,所以会被popad忽略$/;"	m	struct:intr_stack
exception_init	kernel/interrupt.c	/^static void exception_init(void) {$/;"	f	file:
expecting_intr	device/ide.h	/^    bool expecting_intr;        \/\/ 表示等待硬盘的中断$/;"	m	struct:ide_channel
ext_lba_base	device/ide.c	/^int32_t ext_lba_base = 0;$/;"	v
ext_scancode	device/keyboard.c	/^static bool ctrl_status, shift_status, alt_status, caps_lock_status, ext_scancode;$/;"	v	file:
extern	kernel/kernel.S	/^extern idt_table ; idt_table 是 C 中注册的中断处理程序数组$/;"	l
extern	kernel/kernel.S	/^extern syscall_table$/;"	l
f_type	fs/dir.h	/^    enum file_types f_type; \/\/ 文件类型$/;"	m	struct:dir_entry	typeref:enum:dir_entry::file_types
false	kernel/global.h	/^#define false /;"	d
fd_flag	fs/file.h	/^    uint32_t fd_flag;$/;"	m	struct:file
fd_inode	fs/file.h	/^    struct inode* fd_inode;$/;"	m	struct:file	typeref:struct:file::inode
fd_local2global	fs/fs.c	/^static uint32_t fd_local2global(uint32_t local_fd) {$/;"	f	file:
fd_pos	fs/file.h	/^    uint32_t fd_pos; \/\/ 记录当前文件操作的偏移地址, 以 0 为起始, 最大为文件大小 - 1$/;"	m	struct:file
fd_table	thread/thread.h	/^    int32_t fd_table[MAX_FILES_OPEN_PER_PROC]; \/\/ 文件描述符数组$/;"	m	struct:task_struct
file	fs/file.h	/^struct file {$/;"	s
file_close	fs/file.c	/^int32_t file_close(struct file* file) {$/;"	f
file_create	fs/file.c	/^int32_t file_create(struct dir* parent_dir, char* filename, uint8_t flag) {$/;"	f
file_open	fs/file.c	/^int32_t file_open(uint32_t inode_no, uint8_t flag) {$/;"	f
file_table	fs/file.c	/^struct file file_table[MAX_FILE_OPEN];$/;"	v	typeref:struct:file
file_type	fs/fs.h	/^    enum file_types file_type; \/\/ 文件类型$/;"	m	struct:path_search_record	typeref:enum:path_search_record::file_types
file_types	fs/fs.h	/^enum file_types {$/;"	g
file_write	fs/file.c	/^int32_t file_write(struct file* file, const void* buf, uint32_t count) {$/;"	f
filename	fs/dir.h	/^    char filename[MAX_FILE_NAME_LEN]; \/\/ 普通文件或目录名称$/;"	m	struct:dir_entry
filesys_init	fs/fs.c	/^void filesys_init() {$/;"	f
free	lib/user/syscall.c	/^void free(void* ptr) {$/;"	f
free_elem	kernel/memory.h	/^    struct list_elem free_elem;$/;"	m	struct:mem_block	typeref:struct:mem_block::list_elem
free_list	kernel/memory.h	/^    struct list free_list; \/\/ 目前可用的 mem_block 链表$/;"	m	struct:mem_block_desc	typeref:struct:mem_block_desc::list
frequency_set	device/timer.c	/^static void frequency_set(uint8_t counter_port, \\$/;"	f	file:
fs	thread/thread.h	/^    uint32_t fs;$/;"	m	struct:intr_stack
fs	userprog/tss.c	/^    uint32_t fs;$/;"	m	struct:tss	file:
fs_type	device/ide.c	/^    uint8_t  fs_type;		 \/\/ 分区类型$/;"	m	struct:partition_table_entry	file:
func_arg	thread/thread.h	/^    void* func_arg; \/\/ 由 kernel_thread 所调用的函数所需的参数$/;"	m	struct:thread_stack
func_offset_high_word	kernel/interrupt.c	/^    uint16_t func_offset_high_word;$/;"	m	struct:gate_desc	file:
func_offset_low_word	kernel/interrupt.c	/^    uint16_t func_offset_low_word;$/;"	m	struct:gate_desc	file:
function	lib/kernel/list.h	/^typedef bool (function)(struct list_elem*, int arg);$/;"	t
function	thread/thread.h	/^    thread_func* function; \/\/ 由 kernel_thread 所调用的函数名$/;"	m	struct:thread_stack
gate_desc	kernel/interrupt.c	/^struct gate_desc {$/;"	s	file:
gdt_desc	kernel/global.h	/^struct gdt_desc {$/;"	s
gdt_ptr	boot/loader.S	/^gdt_ptr dw GDT_LIMIT$/;"	d
general_intr_handler	kernel/interrupt.c	/^static void general_intr_handler(uint8_t vec_nr) {$/;"	f	file:
general_tag	thread/thread.h	/^    struct list_elem general_tag; \/\/ 用于线程在一般队列中的结点$/;"	m	struct:task_struct	typeref:struct:task_struct::list_elem
get_a_page	kernel/memory.c	/^void* get_a_page(enum pool_flags pf, uint32_t vaddr) {$/;"	f
get_free_slot_in_global	fs/file.c	/^int32_t get_free_slot_in_global(void) {$/;"	f
get_kernel_pages	kernel/memory.c	/^void* get_kernel_pages(uint32_t pg_cnt) {$/;"	f
get_user_pages	kernel/memory.c	/^void* get_user_pages(uint32_t pg_cnt) {$/;"	f
getpid	lib/user/syscall.c	/^uint32_t getpid() {$/;"	f
global	kernel/kernel.S	/^global intr_entry_table$/;"	l
global	kernel/kernel.S	/^global intr_exit$/;"	l
global	kernel/kernel.S	/^global syscall_handler$/;"	l
global	lib/kernel/print.S	/^global put_char$/;"	l
global	lib/kernel/print.S	/^global put_int$/;"	l
global	lib/kernel/print.S	/^global put_str$/;"	l
global	lib/kernel/print.S	/^global set_cursor$/;"	l
global	thread/switch.S	/^global switch_to$/;"	l
gs	thread/thread.h	/^    uint32_t gs;$/;"	m	struct:intr_stack
gs	userprog/tss.c	/^    uint32_t gs;$/;"	m	struct:tss	file:
head	device/ioqueue.h	/^    int32_t head;			    \/\/ 队首,数据往队首处写入$/;"	m	struct:ioqueue
head	lib/kernel/list.h	/^   struct list_elem head;$/;"	m	struct:list	typeref:struct:list::list_elem
holder	thread/sync.h	/^    struct task_struct* holder; \/\/ 锁的持有者$/;"	m	struct:lock	typeref:struct:lock::task_struct
holder_repeat_nr	thread/sync.h	/^    uint32_t holder_repeat_nr;  \/\/ 锁的持有者重复申请锁的次数$/;"	m	struct:lock
i_no	fs/dir.h	/^    uint32_t i_no; \/\/ 普通文件或目录对应的 inode 编号$/;"	m	struct:dir_entry
i_no	fs/inode.h	/^    uint32_t i_no; \/\/ inode 编号$/;"	m	struct:inode
i_open_cnts	fs/inode.h	/^    uint32_t i_open_cnts; \/\/ 记录此文件被打开的次数$/;"	m	struct:inode
i_sectors	fs/inode.h	/^    uint32_t i_sectors[13];$/;"	m	struct:inode
i_size	fs/inode.h	/^    uint32_t i_size;$/;"	m	struct:inode
ide_channel	device/ide.h	/^struct ide_channel {$/;"	s
ide_init	device/ide.c	/^void ide_init() {$/;"	f
ide_read	device/ide.c	/^void ide_read(struct disk* hd, uint32_t lba, void* buf, uint32_t sec_cnt) {$/;"	f
ide_write	device/ide.c	/^void ide_write(struct disk* hd, uint32_t lba, void* buf, uint32_t sec_cnt) {$/;"	f
identify_disk	device/ide.c	/^static void identify_disk(struct disk* hd) {$/;"	f	file:
idle	thread/thread.c	/^static void idle(void* arg UNUSED) {$/;"	f	file:
idle_thread	thread/thread.c	/^struct task_struct* idle_thread;        \/\/ idle 线程$/;"	v	typeref:struct:task_struct
idt	kernel/interrupt.c	/^static struct gate_desc idt[IDT_DESC_CNT]; \/\/ idt 是中断描述符表$/;"	v	typeref:struct:gate_desc	file:
idt_desc_init	kernel/interrupt.c	/^static void idt_desc_init(void) {$/;"	f	file:
idt_init	kernel/interrupt.c	/^void idt_init() {$/;"	f
idt_table	kernel/interrupt.c	/^intr_handler idt_table[IDT_DESC_CNT]; \/\/ 定义中断处理程序数组$/;"	v
inb	lib/kernel/io.h	/^static inline uint8_t inb(uint16_t port) {$/;"	f
init_all	kernel/init.c	/^void init_all() {$/;"	f
init_thread	thread/thread.c	/^void init_thread(struct task_struct* pthread, char* name, int prio) {$/;"	f
inode	fs/dir.h	/^    struct inode* inode;$/;"	m	struct:dir	typeref:struct:dir::inode
inode	fs/inode.h	/^struct inode {$/;"	s
inode_bitmap	device/ide.h	/^    struct bitmap inode_bitmap; \/\/ inode 位图$/;"	m	struct:partition	typeref:struct:partition::bitmap
inode_bitmap_alloc	fs/file.c	/^int32_t inode_bitmap_alloc(struct partition* part) {$/;"	f
inode_bitmap_lba	fs/super_block.h	/^    uint32_t inode_bitmap_lba; \/\/ inode位图起始扇区lba地址$/;"	m	struct:super_block
inode_bitmap_sects	fs/super_block.h	/^    uint32_t inode_bitmap_sects; \/\/ inode位图占用的扇区数量$/;"	m	struct:super_block
inode_close	fs/inode.c	/^void inode_close(struct inode* inode) {$/;"	f
inode_cnt	fs/super_block.h	/^    uint32_t inode_cnt;     \/\/ 本分区中inode数量$/;"	m	struct:super_block
inode_init	fs/inode.c	/^void inode_init(uint32_t inode_no, struct inode* new_inode) {$/;"	f
inode_locate	fs/inode.c	/^static void inode_locate(struct partition* part, $/;"	f	file:
inode_open	fs/inode.c	/^struct inode* inode_open(struct partition* part, uint32_t inode_no) {$/;"	f
inode_position	fs/inode.c	/^struct inode_position {$/;"	s	file:
inode_sync	fs/inode.c	/^void inode_sync(struct partition* part, struct inode* inode, void* io_buf) {$/;"	f
inode_table_lba	fs/super_block.h	/^    uint32_t inode_table_lba;   \/\/ inode表起始扇区lba地址$/;"	m	struct:super_block
inode_table_sects	fs/super_block.h	/^    uint32_t inode_table_sects; \/\/ inode表占用的扇区数量$/;"	m	struct:super_block
inode_tag	fs/inode.h	/^    struct list_elem inode_tag; \/\/ 用于加入已打开的 inode 队列$/;"	m	struct:inode	typeref:struct:inode::list_elem
insw	lib/kernel/io.h	/^static inline void insw(uint16_t port, void* addr, uint32_t word_cnt) {$/;"	f
int16_t	lib/stdint.h	/^typedef signed short int int16_t;$/;"	t
int32_t	lib/stdint.h	/^typedef signed int int32_t;$/;"	t
int64_t	lib/stdint.h	/^typedef signed long long int int64_t;$/;"	t
int8_t	lib/stdint.h	/^typedef signed char int8_t;$/;"	t
intr_disable	kernel/interrupt.c	/^enum intr_status intr_disable() {$/;"	f
intr_enable	kernel/interrupt.c	/^enum intr_status intr_enable() {$/;"	f
intr_entry_table	kernel/kernel.S	/^intr_entry_table:$/;"	l
intr_exit	kernel/kernel.S	/^intr_exit:$/;"	l
intr_get_status	kernel/interrupt.c	/^enum intr_status intr_get_status() {$/;"	f
intr_handler	kernel/interrupt.h	/^typedef void* intr_handler;$/;"	t
intr_hd_handler	device/ide.c	/^void intr_hd_handler(uint8_t irq_no) {$/;"	f
intr_keyboard_handler	device/keyboard.c	/^static void intr_keyboard_handler(void) {$/;"	f	file:
intr_name	kernel/interrupt.c	/^char* intr_name[IDT_DESC_CNT]; \/\/ 用于保存异常的名字$/;"	v
intr_set_status	kernel/interrupt.c	/^enum intr_status intr_set_status(enum intr_status status) {$/;"	f
intr_stack	thread/thread.h	/^struct intr_stack {$/;"	s
intr_status	kernel/interrupt.h	/^enum intr_status {$/;"	g
intr_timer_handler	device/timer.c	/^static void intr_timer_handler(void) {$/;"	f	file:
io_base	userprog/tss.c	/^    uint32_t io_base;$/;"	m	struct:tss	file:
ioq_empty	device/ioqueue.c	/^static bool ioq_empty(struct ioqueue* ioq) {$/;"	f	file:
ioq_full	device/ioqueue.c	/^bool ioq_full(struct ioqueue* ioq) {$/;"	f
ioq_getchar	device/ioqueue.c	/^char ioq_getchar(struct ioqueue* ioq) {$/;"	f
ioq_putchar	device/ioqueue.c	/^void ioq_putchar(struct ioqueue* ioq, char byte) {$/;"	f
ioq_wait	device/ioqueue.c	/^static void ioq_wait(struct task_struct** waiter) {$/;"	f	file:
ioqueue	device/ioqueue.h	/^struct ioqueue {$/;"	s
ioqueue_init	device/ioqueue.c	/^void ioqueue_init(struct ioqueue* ioq) {$/;"	f
irq_no	device/ide.h	/^    uint8_t irq_no;             \/\/ 本通道所用的中断号$/;"	m	struct:ide_channel
itoa	lib/stdio.c	/^static void itoa(uint32_t value, char** buf_ptr_addr, uint8_t base) {$/;"	f	file:
k_block_descs	kernel/memory.c	/^struct mem_block_desc k_block_descs[DESC_CNT]; \/\/ 内核内存块描述符数组$/;"	v	typeref:struct:mem_block_desc
k_thread_a	kernel/main.c	/^void k_thread_a(void* arg UNUSED) {$/;"	f
k_thread_b	kernel/main.c	/^void k_thread_b(void* arg UNUSED) {$/;"	f
kbd_buf	device/keyboard.c	/^struct ioqueue kbd_buf;	   \/\/ 定义键盘缓冲区$/;"	v	typeref:struct:ioqueue
kernel_init	boot/loader.S	/^kernel_init:$/;"	l
kernel_pool	kernel/memory.c	/^struct pool kernel_pool, user_pool;$/;"	v	typeref:struct:pool
kernel_thread	thread/thread.c	/^static void kernel_thread(thread_func* function, void* func_arg) {$/;"	f	file:
kernel_vaddr	kernel/memory.c	/^struct virtual_addr kernel_vaddr;$/;"	v	typeref:struct:virtual_addr
keyboard_init	device/keyboard.c	/^void keyboard_init() {$/;"	f
keymap	device/keyboard.c	/^static char keymap[][2] = {$/;"	v	file:
l_no	device/ide.c	/^uint8_t p_no = 0, l_no = 0;$/;"	v
large	kernel/memory.c	/^    bool large;$/;"	m	struct:arena	file:
ldt	userprog/tss.c	/^    uint32_t ldt;$/;"	m	struct:tss	file:
limit_high_attr_high	kernel/global.h	/^   uint8_t  limit_high_attr_high;$/;"	m	struct:gdt_desc
limit_low_word	kernel/global.h	/^   uint16_t limit_low_word;$/;"	m	struct:gdt_desc
list	lib/kernel/list.h	/^struct list {$/;"	s
list_append	lib/kernel/list.c	/^void list_append(struct list* plist, struct list_elem* elem) {$/;"	f
list_elem	lib/kernel/list.h	/^struct list_elem {$/;"	s
list_empty	lib/kernel/list.c	/^bool list_empty(struct list* plist) {		\/\/ 判断队列是否为空$/;"	f
list_init	lib/kernel/list.c	/^void list_init (struct list* list) {$/;"	f
list_insert_before	lib/kernel/list.c	/^void list_insert_before(struct list_elem* before, struct list_elem* elem) { $/;"	f
list_len	lib/kernel/list.c	/^uint32_t list_len(struct list* plist) {$/;"	f
list_pop	lib/kernel/list.c	/^struct list_elem* list_pop(struct list* plist) {$/;"	f
list_push	lib/kernel/list.c	/^void list_push(struct list* plist, struct list_elem* elem) {$/;"	f
list_remove	lib/kernel/list.c	/^void list_remove(struct list_elem* pelem) {$/;"	f
list_traversal	lib/kernel/list.c	/^struct list_elem* list_traversal(struct list* plist, function func, int arg) {$/;"	f
loader_start	boot/loader.S	/^loader_start:$/;"	l
lock	device/ide.h	/^    struct lock lock;           \/\/ 通道锁$/;"	m	struct:ide_channel	typeref:struct:ide_channel::lock
lock	device/ioqueue.h	/^    struct lock lock;$/;"	m	struct:ioqueue	typeref:struct:ioqueue::lock
lock	kernel/memory.c	/^    struct lock lock; \/\/ 申请内存时互斥$/;"	m	struct:pool	typeref:struct:pool::lock	file:
lock	thread/sync.h	/^struct lock {$/;"	s
lock_acquire	thread/sync.c	/^void lock_acquire(struct lock* plock) {$/;"	f
lock_init	thread/sync.c	/^void lock_init(struct lock* plock) {$/;"	f
lock_release	thread/sync.c	/^void lock_release(struct lock* plock) {$/;"	f
logic_parts	device/ide.h	/^    struct partition logic_parts[8]; \/\/ 逻辑分区数量无限, 本内核支持 8 个$/;"	m	struct:disk	typeref:struct:disk::partition
magic	fs/super_block.h	/^    uint32_t magic;         \/\/ 用来标识文件系统类型$/;"	m	struct:super_block
main	kernel/main.c	/^int main(void) {$/;"	f
main_thread	thread/thread.c	/^struct task_struct* main_thread;        \/\/ 主线程 PCB$/;"	v	typeref:struct:task_struct
make_gdt_desc	userprog/tss.c	/^static struct gdt_desc make_gdt_desc(uint32_t* desc_addr, $/;"	f	file:
make_idt_desc	kernel/interrupt.c	/^static void make_idt_desc(struct gate_desc* p_gdesc, uint8_t attr, intr_handler function) {$/;"	f	file:
make_main_thread	thread/thread.c	/^static void make_main_thread(void) {$/;"	f	file:
malloc	lib/user/syscall.c	/^void* malloc(uint32_t size) {$/;"	f
malloc_page	kernel/memory.c	/^void* malloc_page(enum pool_flags pf, uint32_t pg_cnt) {$/;"	f
max_lba	device/ide.c	/^#define max_lba /;"	d	file:
mem_block	kernel/memory.h	/^struct mem_block {$/;"	s
mem_block_desc	kernel/memory.h	/^struct mem_block_desc {$/;"	s
mem_cpy	boot/loader.S	/^mem_cpy:$/;"	l
mem_init	kernel/memory.c	/^void mem_init() {$/;"	f
mem_pool_init	kernel/memory.c	/^static void mem_pool_init(uint32_t all_mem) {$/;"	f	file:
memcmp	lib/string.c	/^int memcmp(const void* a_, const void* b_, uint32_t size) {$/;"	f
memcpy	lib/string.c	/^void memcpy(void* dst_, const void* src_, uint32_t size) {$/;"	f
memset	lib/string.c	/^void memset(void* dst_, uint8_t value, uint32_t size) {$/;"	f
mfree_page	kernel/memory.c	/^void mfree_page(enum pool_flags pf, void* _vaddr, uint32_t pg_cnt) {$/;"	f
mil_seconds_per_intr	device/timer.c	/^#define mil_seconds_per_intr /;"	d	file:
mount_partition	fs/fs.c	/^static bool mount_partition(struct list_elem* pelem, int arg) {$/;"	f	file:
mtime_sleep	device/timer.c	/^void mtime_sleep(uint32_t m_seconds) {$/;"	f
mul	boot/loader.S	/^    mul dx$/;"	d
mul	boot/mbr.S	/^    mul dx         ; ax = ax * dx$/;"	d
my_channel	device/ide.h	/^    struct ide_channel* my_channel; \/\/ 此块硬盘归属于哪个 ide 通道$/;"	m	struct:disk	typeref:struct:disk::ide_channel
my_disk	device/ide.h	/^    struct disk* my_disk;       \/\/ 分区所属的硬盘$/;"	m	struct:partition	typeref:struct:partition::disk
name	device/ide.h	/^    char name[8];               \/\/ 分区名称$/;"	m	struct:partition
name	device/ide.h	/^    char name[8];               \/\/ 本 ata 通道名称$/;"	m	struct:ide_channel
name	device/ide.h	/^    char name[8]; \/\/ 本硬盘的名称$/;"	m	struct:disk
name	thread/thread.h	/^    char name[16];$/;"	m	struct:task_struct
next	lib/kernel/list.h	/^   struct list_elem* next; \/\/ 后继结点$/;"	m	struct:list_elem	typeref:struct:list_elem::list_elem
next_pos	device/ioqueue.c	/^static int32_t next_pos(int32_t pos) {$/;"	f	file:
off_size	fs/inode.c	/^    uint32_t off_size; \/\/ inode 在扇区内的字节偏移量$/;"	m	struct:inode_position	file:
offset	lib/kernel/list.h	/^#define offset(/;"	d
oflags	fs/fs.h	/^enum oflags {$/;"	g
open_inodes	device/ide.h	/^    struct list open_inodes;    \/\/ 本分区打开的 i 结点队列$/;"	m	struct:partition	typeref:struct:partition::list
open_root_dir	fs/dir.c	/^void open_root_dir(struct partition* part) {$/;"	f
other	device/ide.c	/^    uint8_t other[446]; \/\/ 引导代码$/;"	m	struct:boot_sector	file:
outb	lib/kernel/io.h	/^static inline void outb(uint16_t port, uint8_t data) {$/;"	f
outsw	lib/kernel/io.h	/^static inline void outsw(uint16_t port, const void* addr, uint32_t word_cnt) {$/;"	f
p_mode_start	boot/loader.S	/^p_mode_start:$/;"	l
p_no	device/ide.c	/^uint8_t p_no = 0, l_no = 0;$/;"	v
pad	fs/super_block.h	/^    uint8_t pad[460]; \/\/ 加上 460 字节, 凑够 512 字节 1 扇区大小$/;"	m	struct:super_block
page_dir_activate	userprog/process.c	/^void page_dir_activate(struct task_struct* p_thread) {$/;"	f
page_table_add	kernel/memory.c	/^static void page_table_add(void* _vaddr, void* _page_phyaddr) {$/;"	f	file:
page_table_pte_remove	kernel/memory.c	/^static void page_table_pte_remove(uint32_t vaddr) {$/;"	f	file:
palloc	kernel/memory.c	/^static void* palloc(struct pool* m_pool) {$/;"	f	file:
panic_spin	kernel/debug.c	/^void panic_spin(char* filename, $/;"	f
parent_dir	fs/fs.h	/^    struct dir* parent_dir; \/\/ 文件或目录所在的直接父目录$/;"	m	struct:path_search_record	typeref:struct:path_search_record::dir
part_lba_base	fs/super_block.h	/^    uint32_t part_lba_base; \/\/ 本分区的起始lba地址$/;"	m	struct:super_block
part_tag	device/ide.h	/^    struct list_elem part_tag;  \/\/ 用于队列中的标记$/;"	m	struct:partition	typeref:struct:partition::list_elem
partition	device/ide.h	/^struct partition {$/;"	s
partition_format	fs/fs.c	/^static void partition_format(struct partition* part) {$/;"	f	file:
partition_info	device/ide.c	/^static bool partition_info(struct list_elem* pelem, int arg UNUSED) {$/;"	f	file:
partition_list	device/ide.c	/^struct list partition_list;$/;"	v	typeref:struct:list
partition_scan	device/ide.c	/^static void partition_scan(struct disk* hd, uint32_t ext_lba) {$/;"	f	file:
partition_table	device/ide.c	/^    struct partition_table_entry partition_table[4]; \/\/ 分区表中有 4 项, 共 64 字节$/;"	m	struct:boot_sector	typeref:struct:boot_sector::partition_table_entry	file:
partition_table_entry	device/ide.c	/^struct partition_table_entry {$/;"	s	file:
path_depth_cnt	fs/fs.c	/^int32_t path_depth_cnt(char* pathname) {$/;"	f
path_parse	fs/fs.c	/^static char* path_parse(char* pathname, char* name_store) {$/;"	f	file:
path_search_record	fs/fs.h	/^struct path_search_record {$/;"	s
pcb_fd_install	fs/file.c	/^int32_t pcb_fd_install(int32_t globa_fd_idx) {$/;"	f
pde_ptr	kernel/memory.c	/^uint32_t* pde_ptr(uint32_t vaddr) {$/;"	f
pfree	kernel/memory.c	/^void pfree(uint32_t pg_phy_addr) {$/;"	f
pgdir	thread/thread.h	/^    uint32_t* pgdir; \/\/ 进程自己页表的虚拟地址$/;"	m	struct:task_struct
phy_addr_start	kernel/memory.c	/^    uint32_t phy_addr_start; \/\/ 本内存池所管理物理内存的起始地址$/;"	m	struct:pool	file:
pic_init	kernel/interrupt.c	/^static void pic_init(void) {$/;"	f	file:
pid	thread/thread.h	/^    pid_t pid;$/;"	m	struct:task_struct
pid_lock	thread/thread.c	/^struct lock pid_lock;                   \/\/ 分配 pid 锁$/;"	v	typeref:struct:lock
pid_t	thread/thread.h	/^typedef int16_t pid_t;$/;"	t
pool	kernel/memory.c	/^struct pool {$/;"	s	file:
pool_bitmap	kernel/memory.c	/^    struct bitmap pool_bitmap; \/\/ 位图结构, 用于管理物理内存$/;"	m	struct:pool	typeref:struct:pool::bitmap	file:
pool_flags	kernel/memory.h	/^enum pool_flags {$/;"	g
pool_size	kernel/memory.c	/^    uint32_t pool_size; \/\/ 本内存池字节容量$/;"	m	struct:pool	file:
pop	kernel/kernel.S	/^    pop ds$/;"	d
port_base	device/ide.h	/^    uint16_t port_base;         \/\/ 本通道的起始端口号$/;"	m	struct:ide_channel
prev	lib/kernel/list.h	/^   struct list_elem* prev; \/\/ 前躯结点$/;"	m	struct:list_elem	typeref:struct:list_elem::list_elem
prim_parts	device/ide.h	/^    struct partition prim_parts[4]; \/\/ 主分区顶多是 4 个$/;"	m	struct:disk	typeref:struct:disk::partition
printf	lib/stdio.c	/^uint32_t printf(const char* format, ...) {$/;"	f
printk	lib/kernel/stdio-kernel.c	/^void printk(const char* format, ...) {$/;"	f
priority	thread/thread.h	/^    uint8_t priority; \/\/ 线程优先级$/;"	m	struct:task_struct
process_activate	userprog/process.c	/^void process_activate(struct task_struct* p_thread) {$/;"	f
process_execute	userprog/process.c	/^void process_execute(void* filename, char* name) {$/;"	f
producer	device/ioqueue.h	/^    struct task_struct* producer;$/;"	m	struct:ioqueue	typeref:struct:ioqueue::task_struct
pte_ptr	kernel/memory.c	/^uint32_t* pte_ptr(uint32_t vaddr) {$/;"	f
push	kernel/kernel.S	/^    push ds$/;"	d
put_char	lib/kernel/print.S	/^put_char:$/;"	l
put_int	lib/kernel/print.S	/^put_int:$/;"	l
put_int_buffer	lib/kernel/print.S	/^put_int_buffer    dq    0     ; 定义8字节缓冲区用于数字到字符的转换$/;"	d
put_str	lib/kernel/print.S	/^put_str:$/;"	l
rd_disk_m_16	boot/mbr.S	/^rd_disk_m_16:$/;"	l
rd_disk_m_32	boot/loader.S	/^rd_disk_m_32:$/;"	l
read_from_sector	device/ide.c	/^static void read_from_sector(struct disk* hd, void* buf, uint8_t sec_cnt) {$/;"	f	file:
reg_alt_status	device/ide.c	/^#define reg_alt_status(/;"	d	file:
reg_cmd	device/ide.c	/^#define reg_cmd(/;"	d	file:
reg_ctl	device/ide.c	/^#define reg_ctl(/;"	d	file:
reg_data	device/ide.c	/^#define reg_data(/;"	d	file:
reg_dev	device/ide.c	/^#define reg_dev(/;"	d	file:
reg_error	device/ide.c	/^#define reg_error(/;"	d	file:
reg_lba_h	device/ide.c	/^#define reg_lba_h(/;"	d	file:
reg_lba_l	device/ide.c	/^#define reg_lba_l(/;"	d	file:
reg_lba_m	device/ide.c	/^#define reg_lba_m(/;"	d	file:
reg_sect_cnt	device/ide.c	/^#define reg_sect_cnt(/;"	d	file:
reg_status	device/ide.c	/^#define reg_status(/;"	d	file:
register_handler	kernel/interrupt.c	/^void register_handler(uint8_t vector_no, intr_handler function) {$/;"	f
root_dir	fs/dir.c	/^struct dir root_dir; \/\/ 根目录$/;"	v	typeref:struct:dir
root_inode_no	fs/super_block.h	/^    uint32_t root_inode_no;  \/\/ 根目录所在的inode号$/;"	m	struct:super_block
running_thread	thread/thread.c	/^struct task_struct* running_thread(void) {$/;"	f
sb	device/ide.h	/^    struct super_block* sb;     \/\/ 本分区的超级块$/;"	m	struct:partition	typeref:struct:partition::super_block
schedule	thread/thread.c	/^void schedule(void) {$/;"	f
search_dir_entry	fs/dir.c	/^bool search_dir_entry(struct partition* part, struct dir* pdir, const char* name, struct dir_entry* dir_e) {$/;"	f
search_file	fs/fs.c	/^static int search_file(const char* pathname, struct path_search_record* searched_record) {$/;"	f	file:
searched_path	fs/fs.h	/^    char searched_path[MAX_PATH_LEN]; \/\/ 查找过程中的父路径$/;"	m	struct:path_search_record
sec_cnt	device/ide.c	/^    uint32_t sec_cnt;		 \/\/ 本分区的扇区数目$/;"	m	struct:partition_table_entry	file:
sec_cnt	device/ide.h	/^    uint32_t sec_cnt;           \/\/ 扇区数$/;"	m	struct:partition
sec_cnt	fs/super_block.h	/^    uint32_t sec_cnt;       \/\/ 本分区总共的扇区数$/;"	m	struct:super_block
sec_lba	fs/inode.c	/^    uint32_t sec_lba; \/\/ inode 所在的扇区号$/;"	m	struct:inode_position	file:
section	kernel/kernel.S	/^section .data$/;"	l
section	kernel/kernel.S	/^section .text$/;"	l
section	lib/kernel/print.S	/^section .data$/;"	l
section	lib/kernel/print.S	/^section .text$/;"	l
section	thread/switch.S	/^section .text$/;"	l
select_disk	device/ide.c	/^static void select_disk(struct disk* hd) {$/;"	f	file:
select_sector	device/ide.c	/^static void select_sector(struct disk* hd, uint32_t lba, uint8_t sec_cnt) {$/;"	f	file:
selector	kernel/interrupt.c	/^    uint16_t selector;$/;"	m	struct:gate_desc	file:
self_kstack	thread/thread.h	/^    uint32_t* self_kstack; \/\/ 各内核线程都用自己的内核栈$/;"	m	struct:task_struct
sema_down	thread/sync.c	/^void sema_down(struct semaphore* psema) {$/;"	f
sema_init	thread/sync.c	/^void sema_init(struct semaphore* psema, uint8_t value) {$/;"	f
sema_up	thread/sync.c	/^void sema_up(struct semaphore* psema) {$/;"	f
semaphore	thread/sync.h	/^    struct semaphore semaphore; \/\/ 用二元信号量实现锁$/;"	m	struct:lock	typeref:struct:lock::semaphore
semaphore	thread/sync.h	/^struct semaphore {$/;"	s
set_cursor	lib/kernel/print.S	/^set_cursor:$/;"	l
setup_page	boot/loader.S	/^setup_page:$/;"	l
shift_l_char	device/keyboard.c	/^#define shift_l_char	/;"	d	file:
shift_l_make	device/keyboard.c	/^#define shift_l_make	/;"	d	file:
shift_r_char	device/keyboard.c	/^#define shift_r_char	/;"	d	file:
shift_r_make	device/keyboard.c	/^#define shift_r_make /;"	d	file:
shift_status	device/keyboard.c	/^static bool ctrl_status, shift_status, alt_status, caps_lock_status, ext_scancode;$/;"	v	file:
signature	device/ide.c	/^    uint16_t signature; \/\/ 启动扇区的结束标志是 0x55, 0xaa$/;"	m	struct:boot_sector	file:
sprintf	lib/stdio.c	/^uint32_t sprintf(char* buf, const char* format, ...) {$/;"	f
ss	thread/thread.h	/^    uint32_t ss;$/;"	m	struct:intr_stack
ss	userprog/tss.c	/^    uint32_t ss;$/;"	m	struct:tss	file:
ss0	userprog/tss.c	/^    uint32_t ss0;$/;"	m	struct:tss	file:
ss1	userprog/tss.c	/^    uint32_t ss1;$/;"	m	struct:tss	file:
ss2	userprog/tss.c	/^    uint32_t ss2;$/;"	m	struct:tss	file:
stack_magic	thread/thread.h	/^    uint32_t stack_magic; \/\/ 栈的边界标记, 用于检测栈的溢出$/;"	m	struct:task_struct
start_chs	device/ide.c	/^    uint8_t  start_chs;		 \/\/ 起始柱面号$/;"	m	struct:partition_table_entry	file:
start_head	device/ide.c	/^    uint8_t  start_head;     \/\/ 起始磁头号$/;"	m	struct:partition_table_entry	file:
start_lba	device/ide.c	/^    uint32_t start_lba;		 \/\/ 本分区起始扇区的lba地址$/;"	m	struct:partition_table_entry	file:
start_lba	device/ide.h	/^    uint32_t start_lba;         \/\/ 起始扇区$/;"	m	struct:partition
start_process	userprog/process.c	/^void start_process(void* filename_) {$/;"	f
start_sec	device/ide.c	/^    uint8_t  start_sec;		 \/\/ 起始扇区号$/;"	m	struct:partition_table_entry	file:
status	thread/thread.h	/^    enum task_status status;$/;"	m	struct:task_struct	typeref:enum:task_struct::task_status
std_fd	fs/file.h	/^enum std_fd {$/;"	g
stderr_no	fs/file.h	/^    stderr_no  \/\/ 2 标准错误$/;"	e	enum:std_fd
stdin_no	fs/file.h	/^    stdin_no,  \/\/ 0 标准输入$/;"	e	enum:std_fd
stdout_no	fs/file.h	/^    stdout_no, \/\/ 1 标准输出$/;"	e	enum:std_fd
strcat	lib/string.c	/^char* strcat(char* dst_, const char* src_) {$/;"	f
strchr	lib/string.c	/^char* strchr(const char* str, const uint8_t ch) {$/;"	f
strchrs	lib/string.c	/^uint32_t strchrs(const char* str, uint8_t ch) {$/;"	f
strcmp	lib/string.c	/^int8_t strcmp (const char* a, const char* b) {$/;"	f
strcpy	lib/string.c	/^char* strcpy(char* dst_, const char* src_) {$/;"	f
strlen	lib/string.c	/^uint32_t strlen(const char* str) {$/;"	f
strrchr	lib/string.c	/^char* strrchr(const char* str, const uint8_t ch) {$/;"	f
super_block	fs/super_block.h	/^struct super_block {$/;"	s
swap_pairs_bytes	device/ide.c	/^static void swap_pairs_bytes(const char* dst, char* buf, uint32_t len) {$/;"	f	file:
switch_to	thread/switch.S	/^switch_to:$/;"	l
sync_dir_entry	fs/dir.c	/^bool sync_dir_entry(struct dir* parent_dir, struct dir_entry* p_de, void* io_buf) {$/;"	f
sys_close	fs/fs.c	/^int32_t sys_close(int32_t fd) {$/;"	f
sys_free	kernel/memory.c	/^void sys_free(void* ptr) {$/;"	f
sys_getpid	userprog/syscall-init.c	/^uint32_t sys_getpid(void) {$/;"	f
sys_malloc	kernel/memory.c	/^void* sys_malloc(uint32_t size) {$/;"	f
sys_open	fs/fs.c	/^int32_t sys_open(const char* pathname, uint8_t flags) {$/;"	f
sys_write	userprog/syscall-init.c	/^uint32_t sys_write(char* str) {$/;"	f
syscall	userprog/syscall-init.c	/^typedef void* syscall;$/;"	t	file:
syscall_handler	kernel/kernel.S	/^syscall_handler:$/;"	l
syscall_init	userprog/syscall-init.c	/^void syscall_init(void) {$/;"	f
syscall_nr	userprog/syscall-init.c	/^#define syscall_nr /;"	d	file:
syscall_table	userprog/syscall-init.c	/^syscall syscall_table[syscall_nr];$/;"	v
tab	device/keyboard.c	/^#define tab	/;"	d	file:
tail	device/ioqueue.h	/^    int32_t tail;			    \/\/ 队尾,数据从队尾处读出$/;"	m	struct:ioqueue
tail	lib/kernel/list.h	/^   struct list_elem tail;$/;"	m	struct:list	typeref:struct:list::list_elem
task_status	thread/thread.h	/^enum task_status {$/;"	g
task_struct	thread/thread.h	/^struct task_struct {$/;"	s
thread_all_list	thread/thread.c	/^struct list thread_all_list;            \/\/ 所有任务队列$/;"	v	typeref:struct:list
thread_block	thread/thread.c	/^void thread_block(enum task_status stat) {$/;"	f
thread_create	thread/thread.c	/^void thread_create(struct task_struct* pthread, thread_func function, void* func_arg) {$/;"	f
thread_func	thread/thread.h	/^typedef void thread_func(void*);$/;"	t
thread_init	thread/thread.c	/^void thread_init(void) {$/;"	f
thread_ready_list	thread/thread.c	/^struct list thread_ready_list;          \/\/ 就绪队列$/;"	v	typeref:struct:list
thread_stack	thread/thread.h	/^struct thread_stack {$/;"	s
thread_start	thread/thread.c	/^struct task_struct* thread_start(char* name, $/;"	f
thread_tag	thread/thread.c	/^static struct list_elem* thread_tag;    \/\/ 用于保存队列中的线程结点$/;"	v	typeref:struct:list_elem	file:
thread_unblock	thread/thread.c	/^void thread_unblock(struct task_struct* pthread) {$/;"	f
thread_yield	thread/thread.c	/^void thread_yield(void) {$/;"	f
ticks	device/timer.c	/^uint32_t ticks;          \/\/ ticks是内核自中断开启以来总共的嘀嗒数$/;"	v
ticks	thread/thread.h	/^    uint8_t ticks; \/\/ 每次在处理器上执行的时间嘀嗒数$/;"	m	struct:task_struct
ticks_to_sleep	device/timer.c	/^static void ticks_to_sleep(uint32_t sleep_ticks) {$/;"	f	file:
timer_init	device/timer.c	/^void timer_init() {$/;"	f
times	boot/loader.S	/^times 60 dq 0$/;"	l
times	boot/mbr.S	/^times 510-($-$$) db 0$/;"	l
total_mem_bytes	boot/loader.S	/^total_mem_bytes dd 0$/;"	d
trace	userprog/tss.c	/^    uint32_t trace;$/;"	m	struct:tss	file:
true	kernel/global.h	/^#define true /;"	d
tss	userprog/tss.c	/^static struct tss tss;$/;"	v	typeref:struct:tss	file:
tss	userprog/tss.c	/^struct tss {$/;"	s	file:
tss_init	userprog/tss.c	/^void tss_init() {$/;"	f
two_sec	fs/inode.c	/^    bool two_sec; \/\/ inode 是否跨扇区$/;"	m	struct:inode_position	file:
u_block_desc	thread/thread.h	/^    struct mem_block_desc u_block_desc[DESC_CNT]; \/\/ 用户进程内存块描述符$/;"	m	struct:task_struct	typeref:struct:task_struct::mem_block_desc
u_prog_a	kernel/main.c	/^void u_prog_a(void) {$/;"	f
u_prog_b	kernel/main.c	/^void u_prog_b(void) {$/;"	f
uint16_t	lib/stdint.h	/^typedef unsigned short int uint16_t;$/;"	t
uint32_t	lib/stdint.h	/^typedef unsigned int uint32_t;$/;"	t
uint64_t	lib/stdint.h	/^typedef unsigned long long int uint64_t;$/;"	t
uint8_t	lib/stdint.h	/^typedef unsigned char uint8_t;$/;"	t
unused_retaddr	thread/thread.h	/^    void (*unused_retaddr);$/;"	m	struct:thread_stack
update_tss_esp	userprog/tss.c	/^void update_tss_esp(struct task_struct* pthread) {$/;"	f
user_pool	kernel/memory.c	/^struct pool kernel_pool, user_pool;$/;"	v	typeref:struct:
userprog_vaddr	thread/thread.h	/^    struct virtual_addr userprog_vaddr; \/\/ 用户进程的虚拟地址$/;"	m	struct:task_struct	typeref:struct:task_struct::virtual_addr
va_arg	lib/stdio.c	/^#define va_arg(/;"	d	file:
va_end	lib/kernel/stdio-kernel.c	/^#define va_end(/;"	d	file:
va_end	lib/stdio.c	/^#define va_end(/;"	d	file:
va_list	lib/stdio.h	/^typedef char* va_list;$/;"	t
va_start	lib/kernel/stdio-kernel.c	/^#define va_start(/;"	d	file:
va_start	lib/stdio.c	/^#define va_start(/;"	d	file:
vaddr_bitmap	kernel/memory.h	/^    struct bitmap vaddr_bitmap; \/\/ 虚拟地址用到的位图结构$/;"	m	struct:virtual_addr	typeref:struct:virtual_addr::bitmap
vaddr_get	kernel/memory.c	/^static void* vaddr_get(enum pool_flags pf, uint32_t pg_cnt) {$/;"	f	file:
vaddr_remove	kernel/memory.c	/^static void vaddr_remove(enum pool_flags pf, void* _vaddr, uint32_t pg_cnt) {$/;"	f	file:
vaddr_start	kernel/memory.h	/^    uint32_t vaddr_start; \/\/ 虚拟地址起始地址$/;"	m	struct:virtual_addr
value	thread/sync.h	/^    uint8_t value;$/;"	m	struct:semaphore
vec_no	thread/thread.h	/^    uint32_t vec_no; \/\/ kernel.S 宏 VECTOR 中 %1 压入的中断号$/;"	m	struct:intr_stack
virtual_addr	kernel/memory.h	/^struct virtual_addr {$/;"	s
vsprintf	lib/stdio.c	/^uint32_t vsprintf(char* str, const char* format, va_list ap) {$/;"	f
waiters	thread/sync.h	/^    struct list waiters;$/;"	m	struct:semaphore	typeref:struct:semaphore::list
wakeup	device/ioqueue.c	/^static void wakeup(struct task_struct** waiter) {$/;"	f	file:
write	lib/user/syscall.c	/^uint32_t write(char* str) {$/;"	f
write2sector	device/ide.c	/^static void write2sector(struct disk* hd, void* buf, uint8_t sec_cnt) {$/;"	f	file:
write_deny	fs/inode.h	/^    bool write_deny; \/\/ 写文件不能并行, 进程写文件前检查此标识$/;"	m	struct:inode
